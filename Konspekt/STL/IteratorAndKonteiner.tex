\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[english, russian]{babel}


\title{Стандартные библиотеки: контейнеры и итераторы}

\begin{document}
\maketitle

Стандартная библиотека - коллекция классов и функций написанных на базовом языке С++. 
\\

* Заголовочные файлы стандартной библиотеки C++ не имеют расширения \textcolor{red}{«.h».}
\\

В стандартную библиотеку входит стандартная библиотека шаблонов (STL) - набор шаблонных классов и функций общего назначения. Ядро STL составляют \textcolor{blue}{контейнеры, алгоритмы и итераторы.}
\\
* Т.к. STL состоит из шаблонов, ее алгоритмы применимы к данным практически любого типа.
\\

Алгоритмы обрабатывают содержимое контейнеров. 
\\

Итераторы подобны указателям. Они позволяют циклически опрашивать содержимое контейнера, практически так же, как это делается с помощью указателя. Итераторы объявляются с помощью ключевого слова \textcolor{red}{iterator}. Существует пять типов итераторов:
\\

\begin{table}
\begin{tabular}{|p{3cm}|p{8,3cm}|}

\hline
\textbf{Итераторы} & \textbf{Описание итератора} &
\hline

 Произвольного доступа (RandIter) & Сохраняют и считывают значения; позволяют организовать произвольный доступ к элементам контейнера &
\hline
Двунапраленные (BiIter) &	Сохраняют и считывают значения; обеспечивают инкрементно-декрементное перемещение &
\hline
Однонаправленные (ForIter) &	Сохраняют и считывают значения; обеспечивают только инкрементное перемещение &
\hline
Входные (InIter) &	Считывают, но не записывают значения; обеспечивают только инкрементное перемещение &
\hline
Выходные (OutIter) &	Записывают, но не считывают значения; обеспечивают только инкрементное перемещение &
\hline

\end{tabular}
\end{table}


*В общем случае итератор, имеющий бОльшие возможности доступа, можно использовать вместо итератора с меньшими возможностями. 
\\

*Работа с итераторами такая же, как и с указателями. 
\\

*Также есть реверсивные итераторы, позволяющие перемещаться по последовательности в обратном порядке.
\\

Так в STL очень важны распределители памяти (управляет выделением памяти для контейнера), предикаты (специальные функции, возвращающие значения true/false) и функции сравнения (сравнивают два элемента последовательности)
\\

Контейнеры делятся на последовательные (контейнеры последовательности), ассоциативные и контейнеры-адаптеры. 
\\

\textbf{\underline{Контейнеры последовательности}}
\\

Последовательные контейнеры поддерживают указанный пользователем порядок вставляемых элементов.
\\
 Контейнер \textcolor{red}{vector} ведет себя как массив, но может автоматически увеличиваться по мере необходимости.Он поддерживает прямой доступ и связанное хранение и имеет очень гибкую длину. По этим и многим другим причинам контейнер \textcolor{red}{vector} является наиболее предпочтительным последовательным контейнером для большинства областей применения. Если вы сомневаетесь в выборе вида последовательного контейнера, начните с использования вектора.
 \\
 
 Классическая спецификация:\\ \\
\fcolorbox{black}{cyan}{template <class T, class Allocator = allocator<T> > class vector}
\\где Т - тип сохраняемых данных, а Allocator- распределитель памяти. 
\\

Есть конструкторы для 
\\	- пустого вектора; 
\\	- вектора с \textcolor{red}{num} элементов и \textcolor{red}{val} значениями; 
\\	- создания такого же вектора, как и вектор v; 
\\	- вектора элементами в диапазоне итераторов start и end.
\\
\\

* Чтобы объекты наших классов были элементами вектора, надо определять конструктор по умолчанию и операторы \fcolorbox{black}{magenta}{== и <}.
\\

Объявление:
\\
\\ \fcolorbox{black}{cyan}{vector <int> v; vector <char> cv(5); vector <char> cv(5,'x'); vector <int> iv2(iv)}
\\

* Для вектора определены: \fcolorbox{black}{magenta}{==, <, <=, !=, >, >=, [ ]}
\\

\textbf{Самые важные функции для векторов:}\\

	- \textcolor{blue}{size ()} - возвращает размер вектора

	- \textcolor{blue}{begin() и end()} - возвращение итератора в начало и конец

	- \textcolor{blue}{push\underline{ }back()} - вставляет элемент в конец вектора

	- \textcolor{blue}{insert ()} - вставляет элемент в какое-то место вектора

	- \textcolor{blue}{erase ()} - удаляет указанные элементы
\\

* Доступ к элементам вектора ведется через индексы или итераторы
\\

Контейнер \textcolor{red}{array} обладает некоторыми преимуществами контейнера \textcolor{red}{vector}, однако его длина не обладает такой гибкостью.
\\

Контейнер \textcolor{red}{deque} (двусторонняя очередь) обеспечивает быструю вставку и удаление в начале и в конце контейнера. Он, как и контейнер \textcolor{red}{vector}, обладает преимуществами прямого доступа и гибкой длины, но не обеспечивает связанное хранение. Дополнительные сведения см. в разделе класс \textcolor{red}{deque}.Контейнер \textcolor{red}{deque} (двусторонняя очередь) обеспечивает быструю вставку и удаление в начале и в конце контейнера. Он, как и контейнер vector, обладает преимуществами прямого доступа и гибкой длины, но не обеспечивает связанное хранение.
\\

Контейнер \textcolor{red}{list} — это двунаправленный список, который обеспечивает двунаправленный доступ, быструю вставку и удаления в любом месте контейнера, но не поддерживает прямой доступ к элементам контейнера. Доступ к его элементам последовательный, либо с начала в конец, либо с конца в начало. 
\\

Есть конструкторы для создания:
	- пустого списка;
	
	- списка с \textcolor{red}{num} элементов \textcolor{red}{val} значений;
	
	- такого же списка, как и ob;
	
	- списка, содержащего элементы в диапазоне от итераторов start и end;
\\

* Что объект нашего класса был значением списка нужно определить конструктор по умолчанию и оператор "<".
\\

* Список можно сортировать с помощью функции \textcolor{red}{sort ()};

* Списки можно объединять. Получим один общий список и один пустой.
\\

Контейнер \textcolor{red}{forward\underline{ }list} — однонаправленный список. Это версия контейнера \textcolor{red}{list} только с доступом в прямом направлении.
\\

\textbf{\underline{Ассоциативные контейнеры}}
\\

В ассоциативных контейнерах элементы вставляются в предварительно определенном порядке — например, с сортировкой по возрастанию. Также доступны неупорядоченные ассоциативные контейнеры. Ассоциативные контейнеры можно объединить в два подмножества: сопоставления (set) и наборы (map)
\\

Контейнер \textcolor{red}{map}, который иногда называют словарем, состоит из пар "ключ-значение". Ключ используется для упорядочивания последовательности, а значение связано с ключом. Например, \textcolor{red}{map} может содержать ключи, представляющие каждое уникальное ключевое слово в тексте, и соответствующие значения, которые обозначают количество повторений каждого слова в тексте. \textcolor{red}{map} — это неупорядоченная версия \textcolor{red}{unordered\underline{ }map}.
\\

\textcolor{red}{set} — это контейнер уникальных элементов, упорядоченных по возрастанию. Каждое его значение также является и ключом. \textcolor{red}{set} — это неупорядоченная версия \textcolor{red}{unordered\underline{ }set}.
\\

Контейнеры \textcolor{red}{map} и \textcolor{red}{set} разрешают вставку только одного экземпляра ключа или элемента. Если необходимо включить несколько экземпляров элемента, следует использовать контейнер \textcolor{red}{multimap} или \textcolor{red}{multiset}. Неупорядоченные версии этих контейнеров — \textcolor{red}{unordered\underline{ }multimap} и \textcolor{red}{unordered\underline{ }multiset}.
\\

Упорядоченные контейнеры map и set поддерживают двунаправленные итераторы, а их неупорядоченный аналоги — итераторы с перебором в прямом направлении.
\\

Есть конструкторы для создания:
	- пустого отображения;
	
	- отображения, содержащего те же элементы, что и m;
	
	- отображения с элементами в диапазоне итераторов \textcolor{red}{start и end};
	\\

Чтобы объект нашего класса мог быть использован в качестве ключа, нужно определить конструктор по умолчанию и оператор "<". Все основные операторы сравнения для класса map определены.
\\

* Создать пару ключ можно через конструктор или функцией make\underline{ }pair ();
\\

\textbf{Разнородный поиск в ассоциативных контейнерах}
\\


Упорядоченные ассоциативные контейнеры (сопоставление, мультиотображение, набор и мультинабор) теперь поддерживают разнородный поиск. Это означает, что вам больше не нужно передавать объект точно такого же типа как ключ или элемент в функциях-членах, таких как \textcolor{red}{find()} и \textcolor{red}{lower\underline{ }bound()}. Вы можете передать объект любого типа, для которого определен перегруженный \textcolor{blue}{operator<}, позволяющий выполнять сравнение с типом ключа.
\\

Разнородный поиск включается дополнительно, когда указывается средство сравнения "ромбовидный функтор" \textcolor{red}{std::less<>} или \textcolor{red}{std::greater<>} при объявлении переменной контейнера, как показано ниже:
\\

\fcolorbox{black}{white}{std::set<BigObject, std::less<>> myNewSet;}
\\

В следующем примере показано, как можно перегрузить \textcolor{red}{operator<}, чтобы дать возможность пользователям \textcolor{red}{std::set} выполнять поиск, просто передав небольшую строку, которую можно сравнивать с членом \textcolor{red}{BigObject::id} каждого объекта.
\\


\begin{table}
\begin{tabular}{|p{11,3cm}|}

\hline
#include <set>  
\\#include <string>  
\\#include <iostream>  
\\#include <functional>  

class BigObject 
\\

\\public:  
\\    string id;  
\\    explicit BigObject(const string& s):id(s) {}
\\    bool operator< (const BigObject& other) const  

       \\ return this->id < other.id;  

  \\
 \\   // Other members....  
\\  
\\inline bool operator<(const string& otherId, const BigObject& obj)  

 \\   return otherId < obj.id;  

  \\
\\inline bool operator<(const BigObject& obj, const string& otherId)  

  \\  return obj.id < otherId;  

\hline

\end{tabular}
\end{table}

\textbf{\underline{Контейнеры-адаптеры}}\\

Контейнер-адаптер — это разновидность последовательного или ассоциативного контейнера, который ограничивает интерфейс для простоты и ясности. Контейнеры-адаптеры не поддерживают итераторы.
\\

Контейнер \textcolor{red}{queue} соответствует семантике FIFO (первым поступил — первым обслужен). Первый элемент передается— то есть, помещается в очередь — должен быть первым извлекается— то есть, удаленных из очереди.
\\

Контейнер \textcolor{red}{priority\underline{ }queue} упорядочен таким образом, что первым в очереди всегда оказывается элемент с наибольшим значением.
\\

Контейнер \textcolor{red}{stack} соответствует семантике LIFO (последним поступил — первым обслужен). Последний элемент, отправленный в стек, становится первым извлекаемым элементом.
\\

Поскольку контейнеры-адаптеры не поддерживают итераторы, их нельзя использовать в алгоритмах STL.
\\

\textbf{Требования для элементов контейнеров}
\\

Как правило, элементы, вставленные в контейнер STL, могут быть практически любого типа объекта, если их можно копировать. Элементы, доступные только для перемещения — например, объекты \textcolor{red}{vector<unique\underline{ }ptr<T>>}, создаваемые с помощью \textcolor{red}{unique\underline{ }ptr<>}, — также можно использовать, если вы не вызываете функции-члены, которые пытаются скопировать их.
\\

Деструктору не разрешено вызывать исключение.
\\

Для упорядоченных ассоциативных контейнеров — ранее описанных в этом разделе — необходимо определить открытый оператор сравнения. (По умолчанию это оператор \textcolor{red}{operator<}, однако поддерживаются даже типы, которые не работают с \textcolor{red}{operator<}.)
\\

Для некоторых операций в контейнерах может также потребоваться открытый конструктор по умолчанию и открытый оператор равенства. Например, неупорядоченным ассоциативным контейнерам требуется поддержка сравнения на равенство и хэширования.
\\

\underline{Доступ к элементам контейнера}
\\

Доступ к элементам контейнеров осуществляется с помощью \textcolor{blue}{итераторов}.
\\

\underline{Итератор} — это объект, который может выполнять итерацию элементов в контейнере STL и предоставлять доступ к отдельным элементам. Все контейнеры STL предоставляют итераторы, чтобы алгоритмы могли получить доступ к своим элементам стандартным способом, независимо от типа контейнера, в котором сохранены элементы.\\

Вы можете использовать итераторы явно, с помощью члена и глобальных функций, таких как \textcolor{blue}{begin()} и \textcolor{blue}{end()}, а также операторов ++ и -- для перемещения вперед или назад. Вы можете также использовать итераторы неявно, с циклом range-for или (для некоторых типов итераторов) подстрочным оператором [].\\

В STL началом последовательности или диапазона является первый элемент. Конец последовательности или диапазона всегда определяется как элемент, следующий за последним элементом. Глобальные функции begin и end возвращают итераторы в указанный контейнер. Типичный цикл явных итераторов, включающий все элементы, выглядит следующим образом:\\
\\
\\

\hline
\\
vector<int> vec{ 0,1,2,3,4 };  
\\for (auto it = begin(vec); it != end(vec); it++)  
\\  
\\    // Access element using dereference operator  
\\    cout << *it << " ";  
\\  

\hline
\\
\\

Того же можно достичь более простым способом, с помощью цикла \textcolor{blue}{range-for}:
\\


\hline
\\for (auto num : vec)  
 \\   {  
  \\      // no deference operator  
  \\      cout << num << " ";  
 \\   }

\hline
\\

\underline{Существует пять категорий итераторов:}
\\

\begin{itemize}
\item \textbf{\textsc{Итератор вывода}} - Итератор вывода X может выполнить итерацию последовательности с помощью оператора ++ и один раз записать элемент с помощью оператора *.
\\

\item \textbf{\textsc{Итератор ввода}} - Итератор ввода X может выполнить итерацию последовательности с помощью оператора ++ и прочитать элемент любое количество раз с помощью оператора *. Вы можете сравнить итераторы ввода с помощью операторов ++ и !=. После выполнения приращения любой копии итератора ввода ни одну из других копий нельзя будет безопасно сравнивать, разыменовывать и выполнять приращение.
\\

\item \textbf{\textsc{Однонаправленный}} - Однонаправленный итератор X может выполнять итерацию последовательности с помощью оператора ++ и прочитать любой элемент или записать неконстантные элементы любое количество раз с помощью оператора *. Вы можете получить доступ к членам элементов с помощью оператора -> и сравнить однонаправленные итераторы с помощью операторов == и !=. Вы можете сделать несколько копий однонаправленного итератора, каждая из которых может быть разыменована и для нее может быть выполнено независимое приращение. Однонаправленный итератор, который инициализируется без ссылки на какой-либо контейнер, вызывается в пустом однонаправленном итераторе. Пустые однонаправленные итераторы всегда равны.
\\

\item \textbf{\textsc{Двунаправленный}} - Двунаправленный итератор X может использоваться вместо прямого итератора. Вы можете также выполнить уменьшение двунаправленного итератора, как в --X, X-- или (V = *X--). Получить доступ к членам элементов и сравнить двунаправленные итераторы можно так же, как и однонаправленные итераторы.
\\

\item \textbf{\textsc{Произвольный доступ}} - Итератор произвольного доступа X может использоваться вместо двунаправленного итератора. С итератором произвольного доступа можно использовать подстрочный оператор [] для доступа к элементам. Вы можете использовать операторы +, -, += и -= для перемещения указанного количества элементов вперед или назад, а также для вычисления расстояния между итераторами. Вы можете сравнить двунаправленные итераторы с помощью ==, !=, <, >, <= и >=.
\\
\end{itemize}

Все итераторы можно назначать и копировать. Они считаются простыми объектами и поэтому часто передаются и возвращаются по значению, а не по ссылке. Обратите внимание, что ни одна из операций, описанных выше, не может создавать исключения при выполнении с допустимым итератором.
\\

Иерархия категорий итераторов может быть представлена в виде трех последовательностей. Для доступа в режиме только для записи в последовательность можно использовать любой из следующих итераторов.
\\


\hline
\\output iterator  
\\   -> forward iterator  
\\   -> bidirectional iterator  
\\   -> random-access iterator  
\hline
\\

\\Стрелка вправо означает "могут быть заменены". Любой алгоритм, использующий итератор вывода, должен хорошо работать с прямым итератором, например, но не наоборот.
\\

Для доступа в режиме только для чтения в последовательность можно использовать любой из следующих итераторов.
\\
\\

\hline
\\input iterator  
\\   -> forward iterator  
 \\  -> bidirectional iterator  
\\   -> random-access iterator  
\\
\hline
\\
\\

\\Итератор ввода является самым слабым по всем категориям в этом смысле.
\\

Наконец, для доступа в режиме чтения и записи в последовательность можно использовать любой из следующих итераторов.
\\
\\

\hline
\\forward iterator  
\\   -> bidirectional iterator  
\\   -> random-access iterator  
\\
\hline
\\

\\Указатель на объект всегда можно использовать как итератор произвольного доступа, поэтому он может относиться к любой категории итераторов, если он поддерживает необходимый уровень доступа для чтения и записи в последовательность, которую он обозначает.
\\

Итератор \textcolor{red}{Iterator}, не являющийся указателем на объект, должен также определять типы элементов, необходимые для специализации \textcolor{red}{iterator\underline{ }traits<Iterator>}. Обратите внимание, что эти требования могут быть выполнены путем наследования \textcolor{red}{Iterator} от общего базового класса \textcolor{blue}{iterator}.
\\

Важно знать, каковы возможности и ограничения каждой категории итераторов, чтобы понимать, как итераторы используются контейнерами и алгоритмами в STL.
\\


\end{document}
